# チュートリアル

## インストール

最初に、 Haskell の パッケージ管理ツールである stack をインストールしてください。

```
curl -sSL https://get.haskellstack.org/ | sh
```
本レポジトリを git clone したのち、以下のコマンドで mud をインストールしてください。

```
cd mud
stack build && stack install
```

$HOME/.local/bin/ に mud コマンドがインストールされます。必要であれば $HOME/.local/bin/ を実行パスに追加してください。


## Hello, World! プログラム

コンソールに Hello, World! と表示するプログラムは次のとおりです。

```
puts "Hello, World!"
```

これだけです。この内容を hello.mud としてファイルに保存すると以下のコマンドで実行することができます。

```
% mud run hello.mud
Hello, World!
```

## 四則演算

単純な計算は次のように書くことができます。

```
(1+2)*3   #=> 9
2*3.3     #=> 6.6
```

上の例の #=> は、左側を評価した結果が右側になるという意味になります。

詳しくいうと、9 は Intという型を持つ整数で、6.6 は Doubleという型を持つ倍精度浮動小数点数になります。

上の計算をするために内容をファイルに保存して実行してもいいのですが、この場合には REPLを使うとより簡単です。

```
% mud repl
> (1+2)*3
9
> 
```

mud repl を実行すると、一般に REPL (read-eval-print loop) と呼ばれるモードに入ります。

プロンプト(>)の後に式を入力すると、すぐ次の行に結果が表示され、その繰り返しになります。REPLを抜けるには quit と入力してください。

## 変数

変数の使い方は次のとおりです。

```
> a=1
1
> b=2
2
> a+b
3
```

未定義の変数を参照することはできません。

```
> c
1:variable 'c' not found.
```

また、一度定義した変数を再び定義することはできません。

```
> a=1
1
> a=2
1:variable 'a' already exists
```

変数名には以下のような文字を使うことができます。とくに、変数名の最後に ? や ! を使うことができます。

```
find_devisor
prime?
```

## 関数

整数を2倍にするような単純な関数を考えます。これを double と呼ぶことにすると、その定義は次のように書けます。

```
fun double : Int -> Int = {
  x -> x + x
}
```

意味は次のとおりです。「関数 double の型は Int -> Int (整数を受け取って整数を返す) であり、その本体は引数 x を受け取って x + x を返すものである。」

この関数をつかって 10 を2倍にするにはこう書きます。

```
> double 10
20
```

関数名の後にカッコは必要ありません。

引数が2つの場合の例として、2つの整数を受け取ってそれらを足すだけの関数 add を考えます。

```
fun add : Int -> Int -> Int = {
  x y -> x + y
}
```
使い方はこうなります。
```
> add 10 20
30
```
add の型 Int -> Int -> Int は、引数としてInt と Int を受け取り、Int を返すという意味になります。


## 関数のシンプルな記法

double や add のように簡単な関数は、次のように一行で書くこともできます。

```
fun double : Int -> Int = x -> x + x
fun add : Int -> Int -> Int = x y -> x + y
```

さらに関数の型も省略できます（詳しくは後述）。
```
fun double = x -> x + x
fun add = x y -> x + y
```
なおかつ fun も省略できます（後述）。
```
double = x -> x + x
add = x y -> x + y
```
シンプルでしょう。

## パターンマッチ

関数の定義では、<- の左辺にパターンマッチを使うことができます。たとえば、1からnまでを掛け合わせた数を計算する関数 fact は、次のように定義できます。

```
fun fact : Int -> Int = {
  1 -> 1
  n -> n * fact (n-1)
}

fact 5   #=> 120 (=1*2*3*4*5)
```

fact の定義は、引数のパターンごとに本体を場合分けしたものと考えることができます。

つまり、1 -> 1 の行から fact 1 は 1 になります。fact 2 は、次の行に n=2 としてマッチし、2 * fact 1 が評価されます。fact 1 は 1 となり、結局 fact 2 は 2 となります。

このようにパターンは上から順にテストされ、最初にマッチした行の右辺が実行されます。

## "."演算子によるオブジェクト指向っぽい見た目

整数に1を足したものを返す関数 inc を考えます。
```
fun inc : Int -> Int = {
  x -> x + 1
}

inc 10   #=> 11
```

このようなとき、"." 演算子を使って inc 10 を次のように書くことができます。
```
10.inc   #=> 11
```
inc 10 と 10.inc は完全に同じものであり、つまり "." によって関数の第1引数と関数名の順序を交換することができます。

この記法は、次のように関数の適用が深くなった場合により効果的です。

いま、sort をリストをソートする関数、uniq をリストの重複を除く関数、reverse をリストを逆順にする関数として、次の式を考えます。

```
reverse (uniq (sort [2,4,2,1]))
#=> [4,2,1]
```

この式は、リスト [2,4,2,1] をソートし、重複を取り除き、逆順にしたものを表します。しかし、その意味をとるためには、式を「右から左に」読まなければいけません。

"."演算子を使えば、この式は次のように書けます。

```
[2,4,2,1].sort.uniq.reverse
```
左から右へ、自然な順で読みやすくなりました。

## 多重ディスパッチ

関数は、同じ名前でも、引数の型の組み合わせごとに異なるように定義できます。
関数が呼ばれた際には、引数の型を見た上でどの定義を呼び出すかが決まります。このような仕組みを多重ディスパッチ(multiple dispatch)といいます。

以下、説明を書く。
