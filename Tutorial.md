# チュートリアル

## インストール

インストールの方法は次のとおりです。最初に Haskell の パッケージ管理ツールである stack をインストールしてください。

```
curl -sSL https://get.haskellstack.org/ | sh
```
本レポジトリを git clone したのち、以下のコマンドを実行すると mud がインストールされます。

```
cd mud
stack build && stack install
```

$HOME/.local/bin/ に mud バイナリが設置されますので、必要であれば $HOME/.local/bin/ を実行パスに追加してください。


## Hello, World! プログラム

コンソールに Hello, World! と表示するプログラムは次のようになります。

```
puts "Hello, World!"
```

これだけです。この内容を hello.mud としてファイルに保存し、以下のコマンドで実行します。

```
% mud run hello.mud
Hello, World!
```

## 四則演算

四則演算のような計算は通常どおりにできます。

```
(1+2)*3   #=> 9
2*3.3     #=> 6.6
```
（上の例の #=> は、左側を評価した結果が右側になるという意味を表します）

このような単純な計算の場合には、REPLを使うと便利です。

```
% mud repl
> (1+2)*3
9
> 
```

mud repl を実行すると、一般に REPL (read-eval-print loop) と呼ばれる繰り返しの実行モードになります。

プロンプト(>)が表示され、式の入力を待つ状態になっていますので、式を入力すると結果が次の行に表示されます。そして再び入力待ちになります。REPLを抜けるには quit と入力してください。

## 基本的なデータ型

基本的なデータ型としては次の5つがあります。

* 整数 (Int) : 例 42
* 倍精度浮動小数点数 (Double) : 例 1.23
* 文字列 (String) : 例 "hello, world"
* 真偽値 (Bool) : True, False の二つのみ
* リスト ([a]) : 例 [1,2,3]

文字列は + で連結することができます。
```
"hello " + "world"   #=> "hello world"
```

リスト も + で連結できます。
```
[1,2,3] + [4,5]   #=> [1,2,3,4,5]
```

リストの各要素は同じ型でなければいけません。
たとえば [1,2,3] は型 [Int] を持ち、
["hello", "mud"] は 型 [String] を持つことになります。

ちょっと面白いところでは、真偽値も + 演算を持っています。

```
True + True    #=> True
True + False   #=> True
False + False  #=> False
```

真偽値に対する + は、論理和を表します。合わせて論理積も * で表すことができます。

```
True * True   #=> True
True * False  #=> False

False + True * False => False
```

もちろん、他の言語にある && と || もあります。
```
True && False   #=> False
True || False   #=> False
```

## 変数

変数の使い方は次のとおりです。

```
> a=1
1
> b=2
2
> a+b
3
```

未定義の変数を参照することはできません。

```
> c
1:variable 'c' not found.
```

また、一度定義した変数を再び定義することはできません。

```
> a=1
1
> a=2
1:variable 'a' already exists
```

変数名の例は次のようになります。とくに、変数名の最後に ? や ! を使うことができます。

```
find_devisor
prime?
```

## 関数

うけとった整数を2倍にして返す関数 double は、次のように書くことができます。

```
fun double : Int -> Int = {
  x -> x + x
}
```

double の右側にある : Int -> Int は、「関数 double の型は Int -> Int (整数を受け取って整数を返す) である」ということを表しています。本体は、引数 x を受け取って x + x を返す、という意味です。

double を使って 10 を2倍にするにはこう書きます。

```
> double 10
20
```

関数名の後にカッコは必要ありません。

引数が2つの場合の例として、2つの整数を受け取ってそれらを足すだけの関数 add を考えます。

```
fun add : Int -> Int -> Int = {
  x y -> x + y
}
```
使い方はこうです。
```
> add 10 20
30
```
add の型 Int -> Int -> Int は、引数としてInt と Int を受け取り、Int を返すという意味になります。（Haskellに慣れている人にはいかにもカリー化されているように見えると思いますが、実際にはそうなっていません。）

## 関数のシンプルな記法

double や add のように簡単な関数は、次のように一行で書くこともできます。

```
fun double : Int -> Int = x -> x + x
fun add : Int -> Int -> Int = x y -> x + y
```

さらに関数の型も省略できます（詳しくは後述）。
```
fun double = x -> x + x
fun add = x y -> x + y
```
なおかつ fun も省略できます（後述）。
```
double = x -> x + x
add = x y -> x + y
```
このようにかなりシンプルに書くことでできます。

## パターンマッチ

関数の定義では、<- の左辺にパターンマッチを使うことができます。たとえば、1からnまでを掛け合わせた数を計算する関数 fact は、次のように定義できます。

```
fun fact : Int -> Int = {
  1 -> 1
  n -> n * fact (n-1)
}

fact 5   #=> 120 (=1*2*3*4*5)
```

fact x は、x が1の場合には「1 -> 1」の行にマッチし、結果は 1 となります。
x が 2 の場合には、その次の行に n=2 としてマッチし、2 * fact 1 が評価されます。
このようにパターンは上から順にテストされ、最初にマッチした行の右辺が実行されます。

## "."演算子によるオブジェクト指向っぽい見た目

整数に1を足したものを返す関数 inc を次のように定義します。
```
fun inc : Int -> Int = {
  x -> x + 1
}

inc 10   #=> 11
```

このとき、"." 演算子を使って inc 10 を次のように書くことができます。
```
10.inc   #=> 11
```
このように "." は、関数の第1引数と関数名の順序を交換する作用があります。この記法は、関数の適用が深くなった場合により効果的です。

たとえば次の式を考えます。ここで、sort はリストをソートする関数、uniq はリストの重複を除く関数、reverse はリストを逆順にする関数とします。

```
reverse (uniq (sort [2,4,2,1]))
#=> [4,2,1]
```

この式は、「リスト [2,4,2,1] をソートし、重複を取り除き、逆順にしたもの」を表します。ただしその意味をとるためには、式を「右から左に」読む必要があり、少し読みづらいです。

"."演算子を使えば、この式は次のように書けます。

```
[2,4,2,1].sort.uniq.reverse
```
先ほどのとおり「リスト [2,4,2,1] をソートし、重複を取り除き、逆順にしたもの」と、左から右へ自然な順で読むことができるようになりました。

## 多重ディスパッチ

関数は、同じ名前でも、引数の型の組み合わせごとに異なるように定義できます。
関数が呼ばれた際には、引数の型を見た上でどの定義を呼び出すかが決まります。このような仕組みを多重ディスパッチ(multiple dispatch)といいます。

以下、説明を書く。